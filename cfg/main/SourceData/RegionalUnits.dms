container RegionalUnits : using = "geometries"
{ 	
	unit<uint32> Countries
	: storagename = "= propvalue(store_Countries, 'StorageName')"
	, StorageReadOnly = "True"
	{
		attribute<string>           Label; 
		attribute<string>           ZoneId; 
		attribute<wgs84>            geometry (poly); 
		attribute<wgs84>            geometry_LL (poly) := geometry;
		attribute<WebMercator>      Geometry_WM (poly); 
		attribute<WorldMollweide>   Geometry_MW (poly); 
		attribute<Continents>       Continents_rel; 
		
		unit<uint32>      border_points   := sequence2points(geometry) 
		{
			attribute<dpoint> points_x1000 := point[dpoint] * point_xy(1000d, 1000d, dpoint);
		}
			
		attribute<ipoint> iGeom (poly)    := points2sequence_pso(border_points/points_x1000, border_points/sequence_rel, border_points/ordinal)[ipoint];
	}
	unit<uint32> Sep_units
	: storagename = "= propvalue(store_sep_units, 'StorageName')"
	, StorageReadOnly = "True"
	{
		attribute<string>           ZoneId:= Countries/ZoneId[country_rel] + '_' + string(id(.)); 
		attribute<wgs84>            geometry_LL (poly); 
		attribute<Continents>       Continents_rel; 
		attribute<Countries>        country_rel;
	}
	
	unit<uint32> store_Countries := unique(Local_Units/Country_edit)
	, storagename = "%NetworkModelWorld_DataDir%/Regions/fss/Countries.fss"
	{
		attribute<string>           Label              := Values;
		attribute<string>           ZoneId             := first(Local_Units/GID_0, Local_Units/store_countries_rel);
		attribute<wgs84>            geometry    (poly) := partitioned_union_polygon(Local_Units/geometry[BaseProjection_ip], Local_Units/store_countries_rel)[wgs84];
		attribute<WorldMollweide>   Geometry_MW (poly) := convert(geometry, WorldMollweide);
		attribute<WebMercator>      Geometry_WM (poly) := convert(geometry, WebMercator);
		attribute<Continents>       Continents_rel     := first(Local_Units/Continents_rel, Local_Units/store_countries_rel);
		
		// convert wgs84 geometry to mollweide geometry
		// container Convert_wgs84_xy_to_yx : DisableStorage = "true"
		// {
			// unit<uint32> border_points := sequence2points(geometry)
			// {
				// attribute<wgs84> point_yx := Point(PointCol(point), PointRow(point), wgs84);
			// }
			// unit<uint32> Country_ui32  := range(uint32, 0, uint32(#store_Countries))
			// {
				// attribute<wgs84> Geometry_yx (poly) := points2sequence_pso(border_points/point_yx, border_points/sequence_rel[Country_ui32], border_points/ordinal);
			// }
			// attribute<wgs84> Geometry_yx (poly, ..) := union_data(store_Countries, Country_ui32/Geometry_yx);
		// }
	}
	
	unit<uint32> store_sep_units:= split_polygon(Countries/iGeom), descr = "separated polygons that entail a country."
	, storagename = "%NetworkModelWorld_DataDir%/Regions/fss/sep_units.fss"
	{
		attribute<WGS84>      geometry_LL (poly) := points2sequence_pso(border_points/points_div, border_points/sequence_rel, border_points/ordinal);
		attribute<Continents> Continents_rel     := Countries/Continents_rel[polygon_rel];
		attribute<Countries>  country_rel        := polygon_rel;
		
		unit<uint32>        border_points        := sequence2points(geometry) 
		{
			attribute<WGS84> points_div := (point[dpoint] / point_xy(1000d, 1000d, dpoint))[WGS84];
		}
	}
	
	unit<uint32> Local_Units //Countries 
	: StorageName = "%NetworkModelWorld_DataDir%/Regions/gadm_410.gpkg"
	, StorageType = "gdal.vect"
	, StorageReadOnly = "true"
	{
		attribute<wgs84>            Geometry (poly);
		attribute<string>			Country_edit:= GID_0 = 'RUS' ? Continent_edit + '_' + Country : Country;
		
		attribute<store_Countries>  store_countries_rel  := rlookup(Country_edit, store_Countries/values);
		attribute<Continents>       continents_rel := rlookup(AsItemName(continent_edit), Continents/name);
		attribute<string>           continent_edit := switch(
			case(continent == 'Australia' || continent == 'Oceania', 'Australia_Oceania'), 
			case(GID_0 = 'TUR', 'Europe'), 
			case(isdefined(rus_id) && russian_units/IsEuropean[rus_id], 'Europe'), 
			case(isdefined(rus_id) && !russian_units/IsEuropean[rus_id], 'Asia'), 
			continent);
		attribute<russian_units> 	rus_id:= invert(russian_units/Nr_OrgEntity);

	unit<uint32> russian_units:= subset(GID_0 = 'RUS') { // addition to replace single Russia units with an Asian and European Russian entities (based on OSM coverage)
			attribute<wgs84> Geometry (poly):= Local_Units/Geometry[Nr_OrgEntity];
			attribute<uint32> European_roads:= pcount(point_in_polygon(first_node(Infrastructure/OSM/Per_OSM_Continent/Europe/Roads/geometry), Geometry));
			attribute<uint32> Asian_roads:= pcount(point_in_polygon(first_node(Infrastructure/OSM/Per_OSM_Continent/Asia/Roads/geometry), Geometry));
			attribute<bool>	  IsEuropean:= Asian_roads < European_roads;
		}
	
	}
	
	unit<uint8> Continents := Classifications/Continents
	{
		attribute<wgs84>  geometry (poly) := partitioned_union_polygon(Local_Units/geometry[BaseProjection_ip], Local_Units/continents_rel)[wgs84];
		attribute<string> name            := Classifications/Continents/name;
		attribute<string> label           := Classifications/Continents/label;
		
		container V := for_each_nedv(AsItemName(name), String(ID(.))+'[..]', void, .);

	}
}
