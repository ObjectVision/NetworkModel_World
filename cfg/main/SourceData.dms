container SourceData: Using = "Units;Classifications;geometries"
{
	#include<Infrastructure.dms>
	#include<RegionalUnits.dms>
	
	container Settlements
	{
		unit<uint32> villages // SMOD_V1s6_opr_P2023_v1_2020_labelRC_DB -> villages -> degurba klasse 13
		: StorageName = "%NetworkModelWorld_DataDir%/Settlements/SMOD_V1s6_opr_P2023_v1_2020_labelRC_DB.shp"
		, StorageType = "gdal.vect"
		, DialogData  = "WorldMollweide"
		, DialogType = "Map"
		, StorageReadOnly = "TRUE"
		{
			attribute<WorldMollweide> geometry    (poly);
			attribute<WGS84>          geometry_LL (poly) :=  points2sequence(xy_to_yx/point_yx, xy_to_yx/Sequence_rel);
			attribute<WGS84>          centroid           := CalcPopCentroids/CalcPopCentroids/geometry;
			
			container CalcPopCentroids := CalcPopCentroids_T(.);
			
			unit<uint32> xy_to_yx := sequence2points(geometry[WGS84])
			{
				attribute<WGS84> point_yx := point(PointCol(point), PointRow(point))[WGS84];
			}
		}
		
		unit<uint32> semidensetowns // SMOD_V1s6_opr_P2023_v1_2020_labelSDUC_DB -> semi-dense towns -> degurba klasse 22
		: StorageName = "%NetworkModelWorld_DataDir%/Settlements/SMOD_V1s6_opr_P2023_v1_2020_labelSDUC_DB.shp"
		, StorageType = "gdal.vect"
		, DialogData  = "WorldMollweide"
		, DialogType = "Map"
		, StorageReadOnly = "TRUE"
		{
			attribute<WorldMollweide> geometry    (poly);
			attribute<WGS84>          geometry_LL (poly) :=  points2sequence(xy_to_yx/point_yx, xy_to_yx/Sequence_rel);
			attribute<WGS84>          centroid           := CalcPopCentroids/CalcPopCentroids/geometry;
			
			container CalcPopCentroids := CalcPopCentroids_T(.);
			
			unit<uint32> xy_to_yx := sequence2points(geometry[WGS84])
			{
				attribute<WGS84> point_yx := point(PointCol(point), PointRow(point))[WGS84];
			}
		}
		
		unit<uint32> towns // SMOD_V1s6_opr_P2023_v1_2020_labelDUC_DB -> towns -> degurba klasse 23
		: StorageName = "%NetworkModelWorld_DataDir%/Settlements/SMOD_V1s6_opr_P2023_v1_2020_labelDUC_DB.shp"
		, StorageType = "gdal.vect"
		, DialogData  = "WorldMollweide"
		, DialogType = "Map"
		, StorageReadOnly = "TRUE"
		{
			attribute<WorldMollweide> geometry    (poly);
			attribute<WGS84>          geometry_LL (poly) :=  points2sequence(xy_to_yx/point_yx, xy_to_yx/Sequence_rel);
			attribute<WGS84>          centroid           := CalcPopCentroids/CalcPopCentroids/geometry;
			
			container CalcPopCentroids := CalcPopCentroids_T(.);
			
			unit<uint32> xy_to_yx := sequence2points(geometry[WGS84])
			{
				attribute<WGS84> point_yx := point(PointCol(point), PointRow(point))[WGS84];
			}
		}
		
		unit<uint32> cities // SMOD_V1s6_opr_P2023_v1_2020_labelUC_DB -> cities -> degurba klasse 30
		: StorageName = "%NetworkModelWorld_DataDir%/Settlements/SMOD_V1s6_opr_P2023_v1_2020_labelUC_DB.shp"
		, StorageType = "gdal.vect"
		, DialogData  = "geometry_LL"
		, DialogType = "Map"
		, StorageReadOnly = "TRUE"
		{
			attribute<WorldMollweide> geometry    (poly);
			attribute<WGS84>          geometry_LL (poly) :=  points2sequence(xy_to_yx/point_yx, xy_to_yx/Sequence_rel);
			attribute<WGS84>          centroid           := CalcPopCentroids/CalcPopCentroids/geometry;
			
			container CalcPopCentroids := CalcPopCentroids_T(.);
			
			unit<uint32> xy_to_yx := sequence2points(geometry[WGS84])
			{
				attribute<WGS84> point_yx := point(PointCol(point), PointRow(point))[WGS84];
			}
		}
	}
	
	container Population
	{
		parameter<string> FileName          := '%NetworkModelWorld_DataDir%/population/GHS_POP_E2020_GLOBE_R2023A_54009_1000_V1_0';

		unit<ipoint> big_raster
		:	StorageName     = "= FileName+'.tif'"
		,	StorageReadOnly = "True"
		,	DialogData      = "WorldMollweide"
		, 	LazyCalculated  = "true"
		{ 
			attribute<float64> GridData;                                                            // don't read this; memory will explode
		}
		
		unit<uint64> PopulatedCells := select_with_org_rel(big_raster/GridData > 0d), DialogType = "map", DialogData = "org_rel"  
		{
			attribute<WorldMollweide> org_rel_to_mollweide := convert(org_rel, WorldMollweide);
			attribute<WGS84>          latlon_point         := convert(org_rel_to_mollweide, WGS84);
			attribute<WGS84>          latlon_point_swapped := point(PointCol(latlon_point), PointRow(latlon_point), WGS84);
			attribute<gtopo>          gtopo_rel            := convert(latlon_point_swapped, gtopo);
			attribute<float64>        Population           := big_raster/GridData[org_rel];
			attribute<WGS84>          Geometry             := latlon_point_swapped;

		}
	}
	
	Template CalcPopCentroids_T
	{
		unit<uint32> src;
		///
	
		unit<uint32> CalcPopCentroids := src
		{
			attribute<float64> W          := sum(Population/pop, Population/settlement_rel);
			
			attribute<float64> Weighted_X := sum(Population/x * Population/pop, Population/settlement_rel);
			attribute<float64> Weighted_Y := sum(Population/y * Population/pop, Population/settlement_rel);
			
			attribute<float64> mean_X     := Weighted_X / W;
			attribute<float64> mean_Y     := Weighted_y / W;
			 
			attribute<WGS84>  weighted_centroid0            := point(mean_X, mean_Y, WGS84);
			attribute<bool>   IsWeighted_centroid_in_settl  := IsDefined(point_in_polygon(weighted_centroid0, src/geometry_LL));
			attribute<WGS84>  weighted_centroid             := IsWeighted_centroid_in_settl ? weighted_centroid0 : centroid_or_mid(src/geometry_LL);
			attribute<WGS84>  geometry                      := weighted_centroid;
			
			unit<uint64> Population := SourceData/Population/PopulatedCells
			{
				attribute<src>     settlement_rel := point_in_polygon(geometry, src/geometry_ll);
				attribute<float64> x              := pointcol(geometry);
				attribute<float64> y              := pointrow(geometry);
				attribute<float64> pop            := population[float64];
				
			}
		}
	}
}
